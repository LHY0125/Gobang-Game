# 五子棋AI实现详解

## 算法概述
本五子棋AI采用α-β剪枝优化的极小极大算法，结合专业的棋型评估系统和多层次的威胁检测机制。核心算法流程如下：

1. **威胁检测阶段**：优先检查并阻止玩家即将形成的活四、冲四等威胁
2. **搜索决策阶段**：使用α-β剪枝的极小极大算法搜索最佳落子位置
3. **评估优化**：结合位置权重和棋型价值进行综合评分

## 数据结构

### 棋盘表示
```c
int board[MAX_BOARD_SIZE][MAX_BOARD_SIZE]; // 25x25最大棋盘
```
- `0`表示空位
- `1`表示玩家棋子(X)
- `2`表示AI棋子(○)

### 步数记录
```c
typedef struct {
    int player; // 下棋方(1或2)
    int x, y;   // 坐标(0-based)
} Step;

Step steps[MAX_STEPS]; // 最大步数记录
```

### 方向信息
```c
typedef struct {
    int continuous_chess; // 连续同色棋子数
    bool check_start;     // 起始方向是否开放
    bool check_end;       // 结束方向是否开放
} DirInfo;
```

## 核心函数说明

### 1. ai_move(int depth)
**AI决策主函数**
```c
void ai_move(int depth);
```
- 参数：`depth` - 当前搜索深度
- 流程：
  1. 优先防御：检查并阻止玩家的威胁棋型
  2. 主动进攻：使用α-β剪枝搜索最佳位置
  3. 执行落子

### 2. dfs(int x, int y, int player, int depth, int alpha, int beta, bool is_maximizing)
**α-β剪枝搜索核心**
```c
int dfs(int x, int y, int player, int depth, int alpha, int beta, bool is_maximizing);
```
- 参数：
  - `x,y` - 当前测试位置
  - `player` - 当前玩家
  - `depth` - 剩余搜索深度
  - `alpha/beta` - 剪枝参数
  - `is_maximizing` - 是否最大化玩家(AI)

- 返回值：评估分数

### 3. evaluate_pos(int x, int y, int player)
**位置评估函数**
```c
int evaluate_pos(int x, int y, int player);
```
评估标准：
- 四个方向(水平、垂直、对角线)分别评估
- 考虑棋型(活棋、眠棋)和开放程度
- 加入位置权重(中心区域价值更高)

### 4. count_specific_direction(int x, int y, int dx, int dy, int player)
**方向分析函数**
```c
DirInfo count_specific_direction(int x, int y, int dx, int dy, int player);
```
- 分析特定方向的连续棋子情况
- 返回结构包含：
  - 连续棋子数
  - 两端开放状态

## 评估系统

### 棋型评分标准
| 棋型        | 条件               | 分数  |
|-------------|--------------------|-------|
| 活四        | 两端开放的四连     | 100000|
| 冲四        | 一端开放的四连     | 10000 |
| 活三        | 两端开放的三连     | 5000  |
| 眠三        | 一端开放的三连     | 1000  |
| 活二        | 两端开放的二连     | 500   |
| 眠二        | 一端开放的二连     | 100   |

### 位置权重
- 中心区域奖励：`50 * (BOARD_SIZE - 距离中心曼哈顿距离)`
- 边缘区域：基础分

## 搜索策略

### α-β剪枝优化
1. **极大节点(AI)**：
   - 更新α值
   - 当α ≥ β时剪枝

2. **极小节点(玩家)**：
   - 更新β值
   - 当β ≤ α时剪枝

### 搜索优化
1. **局部搜索**：仅考虑已有棋子周围2格范围内的位置
2. **对称剪枝**：避免重复计算对称位置
3. **深度控制**：默认3层，可通过参数调整

## 威胁检测机制

### 防御优先级
1. 立即阻止的威胁：
   - 活四(必输)
   - 冲四(必须阻挡)
   - 双活三(必须阻挡)

2. 高级威胁：
   - 活三
   - 冲三
   - 多种棋型组合

## 性能优化

1. **评估缓存**：重复位置评估优化
2. **早期终止**：发现必胜/必败立即返回
3. **搜索排序**：优先搜索高价值区域

## 典型场景处理

### 必胜局面
- 直接落子形成五连
- 优先进攻而非防守

### 必防局面
- 检测玩家的活四/冲四
- 强制在关键点落子

### 平衡策略
- 进攻与防守的权重平衡
- 根据局势动态调整